{"name": "test_change_object_patch", "status": "broken", "statusDetails": {"message": "TypeError: Object of type method is not JSON serializable", "trace": "create_new_obj_endpoint = <endpoints.create_obj.CreateObject object at 0x0000027CE01473B0>\n\n    @pytest.fixture()\n    def create_obj(create_new_obj_endpoint):\n        body = {\n            \"name\": fake.name,\n            \"data\": {\n                \"year\": 1982,\n                \"price\": 2805.99,\n                \"CPU model\": \"Intel Core i9DKA\",\n                \"Hard disk size\": \"1 TB DKA\"\n            }\n        }\n>       create_new_obj_endpoint.create_new_obj(body)\n\nconftest.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nendpoints\\create_obj.py:13: in create_new_obj\n    self.response = requests.post(  # из self.response можем получить статус-код (прим: <Response [200]>)\n..\\venv\\Lib\\site-packages\\requests\\api.py:115: in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n..\\venv\\Lib\\site-packages\\requests\\api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\n..\\venv\\Lib\\site-packages\\requests\\sessions.py:575: in request\n    prep = self.prepare_request(req)\n..\\venv\\Lib\\site-packages\\requests\\sessions.py:486: in prepare_request\n    p.prepare(\n..\\venv\\Lib\\site-packages\\requests\\models.py:371: in prepare\n    self.prepare_body(data, files, json)\n..\\venv\\Lib\\site-packages\\requests\\models.py:511: in prepare_body\n    body = complexjson.dumps(json, allow_nan=False)\nC:\\Python312\\Lib\\json\\__init__.py:238: in dumps\n    **kw).encode(obj)\nC:\\Python312\\Lib\\json\\encoder.py:200: in encode\n    chunks = self.iterencode(o, _one_shot=True)\nC:\\Python312\\Lib\\json\\encoder.py:258: in iterencode\n    return _iterencode(o, 0)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.encoder.JSONEncoder object at 0x0000027CE017D010>, o = <bound method Provider.name of <faker.providers.person.en_US.Provider object at 0x0000027CE001E1E0>>\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns\n        a serializable object for ``o``, or calls the base implementation\n        (to raise a ``TypeError``).\n    \n        For example, to support arbitrary iterators, you could\n        implement default like this::\n    \n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                # Let the base class default method raise the TypeError\n                return JSONEncoder.default(self, o)\n    \n        \"\"\"\n>       raise TypeError(f'Object of type {o.__class__.__name__} '\n                        f'is not JSON serializable')\nE       TypeError: Object of type method is not JSON serializable\n\nC:\\Python312\\Lib\\json\\encoder.py:180: TypeError"}, "start": 1713417762134, "stop": 1713417762134, "uuid": "92f2b13e-ff41-4b99-ac58-d633b13884f4", "historyId": "ef1dd2a191ecbf4bf6ce7dbdb7c44bd9", "testCaseId": "ef1dd2a191ecbf4bf6ce7dbdb7c44bd9", "fullName": "tests.test_some_app#test_change_object_patch", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_some_app"}, {"name": "host", "value": "Kirill"}, {"name": "thread", "value": "36896-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_some_app"}]}